## CI/CD:

1. Какие стадии должны быть в любом пайплайне (lint, test, build, deploy etc.)?
   <details>
      <summary> Ответ: </summary>
   
    * ***.pre*** — выполняется до всех этапов,
   
    * ***.post*** — выполняется после всех этапов,
   
    * ***build*** — первый после .pre этап,
   
    * ***test*** — второй этап,
   
    * ***deploy*** — третий этап.

   Подробнее: https://habr.com/ru/post/498436/
   </details>


2. Как и где хранить build artifacts?
   <details>
      <summary> Ответ: </summary>

   ***Артефакт*** - любой файл, который разработчик хочет сохранить на продолжительное время после сборки. Данная возможность может использоваться для хранения дистрибутивов и различных журналов сборок.

   ***Публикация артефакта выполняется с помощью секции artifacts***:

   Здесь все просто, указываем пути к артефактам – в нашем случае все файлы в каталоге releases с расширением *.deb. Указываем, что артефакты необходимо хранить в течение месяца.

   Подробнее: https://bitworks.software/2018-09-16-gitlab-ci-artifacts-deb-build-primer.html
    </details>


3. Что такое артефакт?
   <details>
      <summary> Ответ: </summary>

   ***Артефакт*** - любой файл, который разработчик хочет сохранить на продолжительное время после сборки. Данная возможность может использоваться для хранения дистрибутивов и различных журналов сборок.

   ***Пример:***

   Каждый сервис содержит свои требования к развертыванию. Например, ваше приложение Node.js потребует от вас упаковки вашего сервиса определенным образом, чтобы подготовить его к развертыванию. Это упакованное и готовое состояние является артефактом. Таким образом, артефакт - это просто сервис, который собран, упакован и готов к развертыванию.

   Подробнее: http://www.spbdev.biz/blog/понимание-основных-понятии-ci-cd
    </details>


4. Есть два бренча: dev и stage. Мы забросили Dockerfile в dev, а затем сбилдили в dev и stage. Это будет одним артефактом или разными?
   <details>
      <summary> Ответ: </summary>

    Точно хз

   Подробнее:
    </details>


5. Что вы использовали для автоматизации настройки Jenkins и GitLab CI?
   <details>
      <summary> Ответ: </summary>

   Подробнее: https://habr.com/ru/company/ruvds/blog/522334/ (Про обоих)
    </details>


6. Сравните CI инструментов: Jenkins, GitLab CI, AWS Code Pipeline, GCP cloudbuild, GitHub actions, Circle CI.
   <details>
      <summary> Ответ: </summary>

   Подробнее: ***гугл в помощь, аминь***
    </details>


7. Deployment strategies. Какие существуют и чем отличаются (recreate, blue-green, canary etc.)?
   <details>
      <summary> Ответ: </summary>

   ***Стратегии деплоя***:

    Существует несколько различных типов стратегий развертывания, коими можно воспользоваться в зависимости от цели. Например, вам может потребоваться внести изменения в некое окружение для дальнейшего тестирования, или в подмножество пользователей/клиентов, или возникнет необходимость провести ограниченное тестирование на пользователях, прежде чем сделать некую функцию общедоступной.

   ***Rolling (постепенный, «накатываемый» деплой):***

   Это стандартная стратегия развертывания в Kubernetes. Она постепенно, один за другим, заменяет pod'ы со старой версией приложения на pod'ы с новой версией — без простоя кластера.

   ***Recreate (повторное создание):***

   В этом простейшем типе развертывания старые pod'ы убиваются все разом и заменяются новыми.

   ***Blue/Green (сине-зеленые развертывания):***

   Стратегия сине-зеленого развертывания (иногда ее ещё называют red/black, т.е. красно-чёрной) предусматривает одновременное развертывание старой (зеленой) и новой (синей) версий приложения. После размещения обеих версий обычные пользователи получают доступ к зеленой, в то время как синяя доступна для QA-команды для автоматизации тестов через отдельный сервис или прямой проброс портов.

   ***Canary (канареечные развертывания):***

   Канареечные выкаты похожи на сине-зеленые, но лучше управляются и используют прогрессивный поэтапный подход. К этому типу относятся несколько различных стратегий, включая «скрытые» запуски и А/В-тестирование.

    Эта стратегия применяется, когда необходимо испытать некую новую функциональность, как правило, в бэкенде приложения. Суть подхода в том, чтобы создать два практически одинаковых сервера: один обслуживает почти всех пользователей, а другой, с новыми функциями, обслуживает лишь небольшую подгруппу пользователей, после чего результаты их работы сравниваются. Если все проходит без ошибок, новая версия постепенно выкатывается на всю инфраструктуру.

    Хотя данную стратегию можно реализовать исключительно средствами Kubernetes, заменяя старые pod'ы на новые, гораздо удобнее и проще использовать service mesh вроде Istio.

    Например, у вас может быть два различных манифеста в Git: обычный с тегом 0.1.0 и «канареечный» с тегом 0.2.0. Изменяя веса в манифесте виртуального шлюза Istio, можно управлять распределением трафика между этими двумя deployment'ами.

   ***Dark (скрытые) или А/В-развертывания:***

   Скрытое развертывание — еще одна вариация канареечной стратегии (с ней, кстати, Flagger тоже может работать). Разница между скрытым и канареечным развертыванием состоит в том, что скрытые развертывания имеют дело с фронтендом, а не с бэкендом, как канареечные.

    Другое название этих развертываний — А/В-тестирование. Вместо того, чтобы открыть доступ к новой функции всем пользователям, ее предлагают лишь ограниченной их части. Обычно эти пользователи не знают, что выступают тестерами-первопроходцами (отсюда и термин «скрытое развертывание»).

    С помощью переключателей функциональности (feature toggles) и других инструментов можно следить за тем, как пользователи взаимодействуют с новой функцией, увлекает ли она их или они считают новый пользовательский интерфейс запутанным, и другими типами метрик.

   Подробнее: https://habr.com/ru/company/flant/blog/471620/
    </details>


8. Как реализовать СI/CD для программы, которая зависит от нескольких других программ?
   <details>
      <summary> Ответ: </summary>

   Подробнее: https://qna.habr.com/q/1041024
    </details>


9. GitOps. В чем его преимущества и недостатки?
   <details>
      <summary> Ответ: </summary>

   ***Преимущества и недостатки GitOps:***

    Когда мы читаем о GitOps, нам обещают множество полезных свойств. Проанализируем их критическим взглядом:

   ***Автоматизация ✓*** Мы не производим вручную ни какие-либо правки в Kubernetes, ни синхронизацию состояния из Git. Для последнего есть GitOps-оператор, который отвечает за синхронизацию, выполняя ее полностью автоматически.

   ***Конвергентность ✓*** Система стремится прийти в желаемое состояние и, даже если время от времени происходит рассинхронизация, сама возвращается обратно в требуемое, синхронизированное состояние. Почему может произойти рассинхронизация? Две основные причины: а) что-то изменилось в Kubernetes (ручные или несанкционированные действия и подобное), б) изменения внесены в Git, но еще не доставлены в Kubernetes. В обоих случаях за восстановление синхронизации системы отвечает GitOps-оператор.

   ***Идемпотентность ✓*** Если мы повторим синхронизацию несколько раз, результат первой синхронизации не повлияет на результат второй, они оба не повлияют на третью, и так далее. Впрочем, если у нас имеются уже скомпилированные манифесты, коммитнутые в Git, эта идемпотентность обеспечивается в основном самим Kubernetes и его API, так что в этом смысле заслуги GitOps тут нет.

   ***Детерминизм ✗*** Состояние в Kubernetes целиком и полностью определяется тем, что написано в Git. Как я уже говорил, это неправда, потому что состояние зависит ещё от container registry. Если кто-то изменит состояние реестра, изменит образ в реестре… развалится практически всё. Подробности будут ниже.

   ***Наблюдаемость ✗*** В любой момент времени мы хотим знать, синхронизирована ли наша система. Хотим иметь возможность получать алерт, если это не так. С одной стороны — да, наблюдаемость присутствует: ведь мы знаем, соответствует ли текущий Kubernetes манифесту в Git. Однако мы в то же время не знаем, находится ли наша система в желаемом состоянии. Ведь что такое желаемое состояние? Это комбинация из манифестов (в репозитории Git) и образов контейнеров (в реестре). Вывод: только половина состояния определяется Git, и только половину состояния можно наблюдать.

   ***Аудит ✗*** Необходимо надежно и удобно просматривать все изменения, внесенные в Kubernetes, причем в одном месте. И это место — Git. Но это неправда, потому что мы также должны полагаться на функции аудита используемого container registry. Сопоставление данных аудита из двух систем совсем не назовешь надежным или удобным.

   ***Безопасность ✗*** Речь про запрет прямого доступа CI-системы к кластеру Kubernetes. На первый взгляд, наличие оператора, который находится внутри кластера и pull'ит изменения (без прямого доступа к кластеру извне), кажется более безопасным. Однако CI-система (или пользователь) по-прежнему должны иметь возможность отправлять образы в container registry и обновлять манифесты в Git'е. А это означает, что CI-система (или пользователь) уже имеют весь возможный доступ к кластеру. Изменение доступа с прямого на опосредованный не улучшает безопасность, а создает неправильное ощущение безопасности, что делает всю среду только менее защищенной. Вы должны обеспечить безопасность своего CI, других способов тут нет.

   Подробнее: https://habr.com/ru/company/flant/blog/526102/
    </details>
