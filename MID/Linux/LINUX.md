## Linux:

1. Опишите архитектуру ядра Linux.
    <details>
      <summary> Ответ: </summary>
   
    ***Ядро Linux*** состоит из пяти основных подсистем:

    ***Process Scheduler*** (SCHED) – планировщик процессов, отвечает за контроль над доступом процессов к CPU. Планировщик обеспечивает такое поведения ядра, при котором все процессы имеют справедливый доступ к центральному процессору.

    ***Memory Manager*** (MM) – менеджер памяти, обеспечивает различным процессам безопасный доступ к основной памяти системы. Кроме того, MM обеспечивает работу виртуальной памяти, которая позволяет процессам использовать больше памяти, чем реально доступно в системе. Выделенная, но неиспользуемая память вытесняется на файловую систему, и при необходимости – возвращается из неё обратно в память (swapping).

    ***Virtual File System*** (VFS) – виртуальная файловая система, создаёт абстрактный слой, скрывая детали оборудования, предоставляя общий файловый интерфейс для всех устройств. Кроме того, VFS поддерживает несколько форматов файловых систем, которые совместимы с другими операционными системами.

    ***Network Interface*** (NET) – сетевые интерфейсы, обеспечивает работу с различными сетевыми стандартами и сетевым оборудованием.

    ***Inter-Process Communication*** (IPC) – межпроцессная подсистема, поддерживающая несколько механизмов для process-to-process связей в единой Linux-системе.

    Основной подсистемой является планировщик процессов: все остальные системы зависят от него, так как всем им необходимо приостанавливать и возобновлять выполнение процессов. Как правило, процесс приостанавливается в ожидании каких-либо операций с оборудованием, и возобновляет выполнение, когда операция завершена. Например – когда процесс пытается отправить некое сообщение по сети, сетевой интерфейс может приостановить выполнение процесса, пока сетевое оборудование выполняет отправку сообщения. После того как сообщение отправлено (или – получено сообщение об ошибке) – сетевой интерфейс возобновляет работу процесса, передавая ему код возврата, который указывает на успешное завершение операции, или ошибку её при выполнении. Все остальные подсистемы (memory manager, virtual file system и inter-process communication) так же зависят от планировщика процессов по схожим причинам.

    Другие зависимости не так явны, но не менее важны:

    ***Планировщик процессов использует менеджер памяти***, что бы согласовывать карту памяти для каждого процесса, когда он возобновляет своё выполнение;

    ***Подсистема IPC зависит от менеджера памяти*** для поддержания механизма использования общей памяти; этот механизм позволяет двум процессам получить доступ к области общей памяти, в дополнение к их приватной памяти;

    ***Виртуальная файловая система использует сетевые интерфейсы*** для обеспечения работы NFS (Nework File System), и использует менеджер памяти для обеспечения работы устройства RAM drive;

    ***Менеджер памяти использует подсистему виртуальной файловой системы*** для поддержки swapping-а, и это единственная причина, по которой менеджер памяти зависит от файловой системы; когда процесс запрашивает доступ к участку памяти, который уже был вытеснен на диск (swapped out) – менеджер памяти выполняет запрос к файловой системе, что бы получить обратно данные из хранилища (swap-раздела или swap-файла), а выполнение процесса на это время приостанавливается.

    Кроме зависимостей, которые видны явно, все подсистемы ядра зависят  от некоторых общих ресурсов, которые не показаны тут. Сюда входят процедуры, которые используют все подсистемы ядра для выделения (allocate) им и/или высвобождения ими памяти для использования ядром, процедуры для сообщений об ошибках и проблемах, и прочее.

    ***Структуры системы данных***:

    ***Task list***: планировщик процессов поддерживает блок данных для активного процесса. Эти блоки данных хранятся в связанных с процессом списке, который называется “task list” (или – структура task_struct);

   ***Memory Map***: – менеджер памяти хранит карту адресов виртуальной памяти, связанной с адресами памяти физической в основе каждого процесса, а так же хранит дополнительную информацию о получении и замене конкретных страниц памяти; эта информация хранится в структуре данных “process memory-map“, которая в свою очередь хранится в task list планировщика процессов;

   ***I-nodes*** – виртуальная файловая система использует index-nodes (inodes) для представления файлов в логике файловой системы. Структура данных inodes хранит в себе карту адресов блоков, связанную с физическими адресами устройства хранения. inode может совместно использоваться несколькими процессами, если они открывают один и от же файл.

   ***Связь данных*** – все структуры данных хранятся в task list планировщика процессов. Каждый процесс в системе имеет структуру данных, содержащую указатели на его карту памяти, указатели на inode-ы открытых им файлов, а так же – task list содержит указатели на структуры данных, которые представляют собой открытые сетевые соединения, связанные с каждой задачей.

    Подробнее: https://rtfm.co.ua/ru/linux-arxitektura-yadra-linux-obshhaya-arxitektura-sistemy/
   </details>


2. Что такое ядро и каково его предназначение?
    <details>
      <summary> Ответ: </summary>

    ***Ядро́ (англ. kernel)*** — центральная часть операционной системы (ОС), обеспечивающая приложениям координированный доступ к ресурсам компьютера, таким как процессорное время, память, внешнее аппаратное обеспечение, внешнее устройство ввода и вывода информации. Также обычно ядро предоставляет сервисы файловой системы и сетевых протоколов.

    Как основополагающий элемент ОС ядро представляет собой наиболее низкий уровень абстракции для доступа приложений к ресурсам системы, необходимым для своей работы. Как правило, ядро предоставляет такой доступ исполняемым процессам соответствующих приложений за счёт использования механизмов межпроцессного взаимодействия и обращения приложений к системным вызовам ОС.    

    Описанная задача может различаться в зависимости от типа архитектуры ядра и способа её реализации.

    Подробнее: https://ru.wikipedia.org/wiki/Ядро_операционной_системы
    </details>    


3. Опишите общие части файловой системы Unix/Linux, архитектуру файловой системы.
   <details>
      <summary> Ответ: </summary>

   Подробнее: http://gentoo.theserverside.ru/book/ar67s02.html
   </details>


4. В чем разница между RedHat и Debian?
    <details>
      <summary> Ответ: </summary>

   ***Debian*** использует пакеты deb. Debian использует менеджер пакетов dpkg. ***RedHat*** использует средство разрешения зависимостей yum. Ядро и производительность - оптимизированный многоядерный процессор, динамически переключаемые планировщики ввода-вывода перед очередью.

    Подробнее: https://ru.education-wiki.com/8006331-redhat-vs-debian
    </details>


5. В чем разница между /proc и /sys?
    <details>
      <summary> Ответ: </summary>

    В чем-то содержимое каталога (по назначению) /sys схоже с каталогом /proc . Основное отличие в том, что файлы в /sys описывают реальную конфигурацию компьютера на текущий момент. /sys очень тесно связан с udev если вы подключаете (отключаете) устройства, содержимое каталога /sys динамически меняется.

    Подробнее: http://igorka.com.ua/2009-10-06/lekciya-6-katalogi-proc-sys-blochnye-i-simvolnye-fajly-ustrojstva/
    </details>
    

6. Ситуация: указывает, что на диске занято 50% места, а сделать файл даже под root юзером не можем. В чем проблема?
    <details>
      <summary> Ответ: </summary>
    
    хз

    Подробнее:
    </details>


7. Мы удалили файл, открывший приложение. Как нам его восстановить?
    <details>
      <summary> Ответ: </summary>

   Восстанавливаем файл

    Первым делом нам нужно убедиться что у нас стоит приложение lsof и примонтирован procfs в /proc.

    В этой заметке я буду считать что в системе где будут восстанавливаться открытые файлы все нужные приложения стоят, root доступ есть, всё примонтировано как нужно.

    Первым делом нам нужно найти открытый файл с помощью программы lsof:
    
    > $ sudo lsof | grep filename

    Пример:
    
    > $ sudo lsof | grep /home/anton/.xsession-errors
   > 
    > kwin 2031 4002 anton 2w REG 253,3 4486557 1835028 /home/anton/.xsession-errors

    Нас интересуют вот эти значения:

    1: Номер процесса (pid)
   
    2: Файловый дескриптор (file descriptor)

    Здесь я выделю жирным то что нужно:
    
    > kwin **2031** 4002 anton **2**w REG 253,3 4486557 1835028 /home/anton/.xsession-errorsЗдесь я выделю жирным то что нужно:
   > 

    Дальше восстанавливаем его (вы можете также его сохранить в другом месте):
    
    > $ sudo cp /proc/2031/fd/2 /home/anton/.xsession-error

    На этом всё, так можно восстановить открытый файл, но который по какой-то причине был удален.

    Подробнее: https://habr.com/ru/post/208104/
    </details>


8. Как найти PID процесса, его стартовые параметры?
    <details>
      <summary> Ответ: </summary>

    КАК УЗНАТЬ PID ПРОЦЕССА LINUX:

    1: ***PS***
   
    > ps aux | grep имя_процесса | grep -v grep

    2: ***PGREP***

    > pgrep -f имя_процесса

    3: ***PIDOF*** - Эта утилита ищет PID конкретного процесса по его имени. Никаких вхождений, имя процесса должно только совпадать с искомым.

    > pidof имя_процесса

    4: ***PSTREE*** - Утилита pstree позволяет посмотреть список дочерних процессов для определённого процесса, также их pid-идентификаторы.

    > pstree -p | grep имя_процесса

    Подробнее: https://losst.pro/kak-uznat-pid-protsessa-v-linux#Как_узнать_PID_скрипта
    </details>


9. Как проверить, открыт ли порт на удаленном хосте, локальном хосте?
    <details>
      <summary> Ответ: </summary>

    Введите: «***telnet + IP-адрес или имя хоста + номер порта***» (например, telnet www.synology.com 1723 или telnet 10.17. xxx. xxx 5000), чтобы запустить команду telnet и протестировать состояние порта. Если порт открыт, отобразится сообщение: Выполнено подключение к 10.17.

    Подробнее: https://kb.synology.com/ru-ru/DSM/tutorial/Whether_TCP_port_is_open_or_closed#x_anchor_id6
    </details>


10. Как искать файл по его содержимому?
    <details>
      <summary> Ответ: </summary>

    Поиск по содержимому файлов командой:

    1: ***grep***

    Секрет популярности — её мощь, она отдает возможность пользователям сортировать и фильтровать текст на основе сложных правил.

    > grep -r -n «text» /path

    > grep -r "Строчка для поиска"

    > grep -rl $'\xEF\xBB\xBF'
    
    2: ***find***

    Своего рода швейцарским ножом в розыске файлов является команда find. Отметим, что она имеет множество опций, которые смогут кардинально изменять механизм поиска.

    > find ~/ -name *.cpp
    
    > find ~/ -name *.cpp -user 'my-username' -group 'my-group'

    > find ~/ -name '*.config' -type f -exec grep 'user' {} \;
    
    > find /home/ ( -name "*.php" -or -name "*.html" -or -name "*.js" )
    
    3: ***which***

    Бригада which ищет только те файлы, у которых есть право на выполнение как программы.

    > which cat

     /bin/cat
    
    > which docker-stack
    
     /home/username/.local/bin/docker-stack

    4: ***locate***

    Команда locate может быть полезна лишь при поиске файла по его имени.

    > locate query

    > locate -b query

    Подробнее: https://linux16.ru/articles/poisk-po-soderzhimomu-fajlov-v-linux.html
    </details>


11. Что такое SSH, как организовать доступ на сервер без пароля или с определенных хостов? Как ограничить доступные для выполнения команды?
    <details>
      <summary> Ответ: </summary>

    ***SSH (англ. Secure Shell — «безопасная оболочка»)*** — сетевой протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).

    ***SSH позволяет*** безопасно передавать в незащищённой среде практически любой другой сетевой протокол. Таким образом, можно не только удалённо работать на компьютере через командную оболочку, но и передавать по шифрованному каналу звуковой поток или видео (например, с веб-камеры)[2]. Также SSH может использовать сжатие передаваемых данных для последующего их шифрования, что удобно, например, для удалённого запуска клиентов X Window System.

    ***Выполнение входа через SSH с использованием ключей***:

    Аутентификация с помощью ключей реализуется путем создания пары ключей: приватного ключа и публичного ключа.

    Приватный ключ располагается на клиентском компьютере, этот ключ защищен и хранится в секрете.

    Публичный ключ может передаваться любому лицу или размещаться на сервере, доступ к которому вы хотите получить.

    При попытке подключения с использованием пары ключей сервер будет использовать публичный ключ для создания сообщения для клиентского компьютера, которое может быть прочитано только с помощью приватного ключа.

    Затем клиентский компьютер отправляет соответствующий ответ обратно серверу, после чего сервер будет знать, что клиент не является поддельным.

    Весь этот процесс выполняется в автоматическом режиме после того, как вы настроите ключи.

    ***Как ограничить доступные для выполнения команды***?

    https://habr.com/ru/post/437710/

    Подробнее: https://www.digitalocean.com/community/tutorials/how-to-use-ssh-to-connect-to-a-remote-server-ru
    </details>


12. Как проверить потреблённые ресурсы во время сеанса SSH?
    <details>
      <summary> Ответ: </summary>

    ***ОЗУ***: cat /proc/meminfo

    ***CPU***: cat /proc/cpuinfo

    ***HDD***: fdisk -l

    Подробнее: https://qna.habr.com/q/464813
    </details>


13. Что означает разрешение на файл 755?
    <details>
      <summary> Ответ: </summary>

    Приведем пример: У файла установлены права 755. Первая цифра — 7, это значит, что хозяин имеет на файл все права: чтение, запись и запуск (7 — 111). Вторая цифра — 5, пользователи из одной с хозяином группы имеют возможность читать и запускать файл, но не могут в него писать (5 — 101).

    Подробнее: http://www.vsmirnov.ru/articles/access.html
    </details>


14. Что такое SELinux и зачем он нужен?
    <details>
      <summary> Ответ: </summary>

    ***SELinux (англ. Security-Enhanced Linux — Linux с улучшенной безопасностью)*** — реализация системы принудительного контроля доступа, которая может работать параллельно с классической избирательной системой контроля доступа.

    Оставаясь в рамках избирательной системы контроля доступа, операционная система имеет фундаментальное ограничение в плане разделения доступа процессов к ресурсам — доступ к ресурсам основывается на правах доступа пользователя. Это классические права rwx на трех уровнях — владелец, группа-владелец и остальные.

    В SELinux права доступа определяются самой системой при помощи специально определенных политик. Политики работают на уровне системных вызовов и применяются самим ядром (но можно реализовать и на уровне приложения). SELinux действует после классической модели безопасности Linux. Иными словами, через SELinux нельзя разрешить то, что запрещено через права доступа пользователей или групп    

    Подробнее: https://ru.wikipedia.org/wiki/SELinux
    </details>


15. Как определить PCI-устройство в системе, например, RAID controller?
    <details>
      <summary> Ответ: </summary>

    Подробнее: https://habr.com/ru/company/neobit/blog/162769/
    </details>


16. Как переименовать устройство, например, сетевую карту или диск?
    <details>
      <summary> Ответ: </summary>

    На вашем виртуальном сервере всегда расположено несколько сетевых интерфейсов, предназначенных для выхода в глобальную или локальную сеть. Вы можете просмотреть их имена и настройки параметров, воспользовавшись командой ifconfig:
    
    > ifconfig -a
    
    Ноды интерфейсов по умолчанию не создаются. Проверить их наличие позволяет команда udevadm:
    
    > udevadm info -n /sys/class/net/<имя_интерфейса>
    
    Пример
    
    > udevadm info -n /sys/class/net/ens192

    Необходимо создать правило udev для сетевого интерфейса, в нашем примере использован ens192. Далее в каталоге /etc/udev/rules.d надо создать файл с именем 1-user-udev.rules, в который оптимально записывать собственные правила:
    
    > touch /etc/udev/rules.d/1-user-udev.rules
    
    С помощью текстового редактора (можно использовать nano) откройте файл для редактирования:
    
    > nano /etc/udev/rules.d/1-user-udev.rules
    
    Вставьте эту строку:
    
    > KERNEL=="<имя интерфейса>", ATTR{address}=="", NAME=”удобное для вас имя"
    
    Пример:
    
    > KERNEL=="ens192", ATTR{address}=="00:50:56:01:27:c2", NAME="wan"
    
    Подробнее: https://cloudlite.ru/faq/kak-pereimenovat-setevye-interfeysy-pri-pomoshchi-udev-pravil/
    </details>


17. Что такое LVM? Какие знаете примеры использования?
    <details>
      <summary> Ответ: </summary>

    ***LVM*** - Logical Volume Management или Управление Логическими Томами.

    ***LVM*** — это дополнительный слой абстракции от железа, позволяющий собрать кучи разнородных дисков в один, и затем снова разбить этот один именно так как нам хочется.

    ***Есть 3 уровня абстракции***:

    ***PV (Physical Volume)*** — физические тома (это могут быть разделы или целые «неразбитые» диски)

    ***VG (Volume Group)*** — группа томов (объединяем физические тома (PV) в группу, создаём единый диск, который будем дальше разбивать так, как нам хочется)

    ***LV (Logical Volume)*** — логические разделы, собственно раздел нашего нового «единого диска» ака Группы Томов, который мы потом форматируем и используем как обычный раздел, обычного жёсткого диска.
    
    Подробнее: https://habr.com/ru/post/67283/ (примеры)
    </details>


18. Что такое root reserved space?
    <details>
      <summary> Ответ: </summary>

    Уменьшение зарезервированного пространства для root (Reserved Space / Reserved block)

    По умолчанию резервируется 5% пространства для root пользователя, чтобы не забить весь диск и, тем самым, не нарушить работу операционной системы (пользователь root доступно всё место). Т.е. обычному пользователю по умолчанию доступно 95 % места, а root 100%.

    Подробнее: https://evgeniyosipov.blogspot.com/2019/02/root-reserved-space-reserved-block-linux.html
    </details>


19. Что такое exit code и как его узнать?
    <details>
      <summary> Ответ: </summary>

    ***Что такое код вывода в оболочке bash***?

    Каждая команда Linux или Unix, выполняемая скриптом оболочки или пользователем, имеет статус вывода.

    ***Статус вывода – это целое число***.

    ***0 состояние выхода*** означает, что команда была успешной без каких-либо ошибок.

    ***Ненулевое (1-255 значений) состояние выхода*** означает, что команда была неудачной.

    ***Как узнать код вывода команды***:

    Вам нужно использовать определенную переменную оболочки с именем $? чтобы получить статус вывода из ранее выполненной команды.

    Выведем $? переменной используя команду echo или команду printf:

    > date
    > 
    > echo $? 
    >
    > 0
    > 
    > date-foo-bar
    >
    > printf '%d\n' $?
    >
    > 127

    Из приведенных выше выводов ясно, что код вывода 0 означает, что команда date была успешной.

    Кроме того, код вывода – 127 (не ноль), так как команда nonexistant не была успешной.

    Подробнее: https://itisgood.ru/2018/12/10/bash-poluchit-kod-zavershenija-komandy-v-linux-unix/
    </details>


20. Почему вывод df -h указывает, что на диске занято мало места, но система не дает записать файл с сообщением “no space left on device”?
    <details>
      <summary> Ответ: </summary>

    ***Время от времени запускайте балансировку для профилактики***. Журнал и метаданные (особенно в более старых версиях ФС) имеют свойство сильно разрастаться, в результате чего Вы будете видеть, что свободного места хоть отбавляй, а по факту - при попытке записать файл, обновить систему вы получите ошибку No space left on device. Для устранение которой придется где то искать дополнительный носитель, для того что бы расширить существующую ФС на него или перенести часть файлов.

    Подробнее: https://help.ubuntu.ru/wiki/btrfs
    </details>


21. В чем разница между command1 & command2 и command1 && command2, а также command1 && command2 || command3?
    <details>
      <summary> Ответ: </summary>

    Подробнее: http://citforum.ru/operating_systems/linux/user/gl-05/gl_05_03.shtml
    </details>


22. Из сети резко вырос исходящий трафик на 25-й порт. Как, имея доступ на гейтвей, обнаружить вредителя из внутренней сети?
    <details>
      <summary> Ответ: </summary>
        хз
    Подробнее:
    </details>


23. Как затюнить параметры Linux Kernel?
    <details>
      <summary> Ответ: </summary>

    Подробнее: https://freehost.com.ua/ukr/faq/articles/tjuning-raboti-servera-pod-bolshie-nagruzki/
    </details>


24. Что такое ulimits?
    <details>
      <summary> Ответ: </summary>

    ***Ulimit*** — это встроенная команда оболочки, предназначенная для отображения, распределения и ограничения ресурсов. Для любой системы важно регулировать эти типы контроля. Этот тип управления может быть применен на глобальном, групповом и пользовательском уровнях.
    
    Подробнее: https://andreyex.ru/linux/komandy-linux-i-komandy-shell/upravlenie-resursami-sistemy-s-pomoshhyu-komandy-ulimit/
    </details>


25. В чем разница между символическими и hard links?
    <details>
      <summary> Ответ: </summary>

    ***Символьная ссылка*** (сокр. «symlink» от англ «symbolic link«), в отличие от ***жесткой ссылки***, указывает не на индексный номер файла, а на его имя (путь). В каком-то роде символьная ссылка является аналогом ярлыка в Windows-системах.

    ***Символическая ссылка***:

    Указывает на целевой файл или каталог. Фактически является небольшим файлом, содержащим путь до целевого файла.

    Не содержит внутри себя содержимого самого файла. Содержит путь к целевому файлу.

    Имеет собственные права доступа, которые не распространяются на целевой файл.

    Удаление / переименование / перемещение целевого файла не обновляет автоматически ссылку. Ссылка начинает указывать на несуществующий файл, становится неработающей.

    Изменение прав доступа у целевого файла не обновляет права доступа у ссылки.

    Может быть создана для директории.

    Ссылка и целевой файл имеют разные файловые индексы (inode) в файловой системе.

    Может указывать на несуществующий файл.

    Символическая ссылка может использовать относительный путь до целевого файла.

    ***Жесткая ссылка***:

    Является своего рода еще одним именем на файл.

    Не может указывать на директорию.

    Нельзя создавать жесткие ссылки между файлами разных файловых систем.

    Не может указывать на несуществующий файл.

    Жесткая ссылка и файл, для которого она создавалась, имеют одинаковые индексы (inode) в файловой системе.

    Подробнее: https://pingvinus.ru/note/ln
    </details>


26. Что такое фрагментация ext3 и ext4?
    <details>
      <summary> Ответ: </summary>

    ***Файловые системы*** - ext3 и ext4

    ***Фрагментация данных*** — разбиение файла на фрагменты различной величины для записи в различные (не последовательные) области жёсткого диска.

    Подробнее: http://xgu.ru/wiki/Фрагментация_файловой_системы
    </details>


27. Зачем файловые системы ext* резервируют 5% места?
    <details>
      <summary> Ответ: </summary>

    Потерпев неудачу при записи данных, программы просто прекращают работу, а иногда даже рушатся! Чтобы предотвратить такой сценарий, файловые системы ext2 и ext3 резервируют 5% от общего пространства для приложений, выполняющихся от имени root.

    Подробнее: https://forum.ubuntu.ru/index.php?topic=97331.0
    </details>


28. Как увеличить размер файловой системы?
    <details>
      <summary> Ответ: </summary>

    Для наращивания файловой системы GFS2 используется команда ***gfs2_grow***. Обычно это применяется в случаях, если был увеличен размер устройства, на котором расположена файловая система. Выполнение команды gfs2_grow в существующей GFS2 приведет к заполнению свободного пространства между текущей границей файловой системы и новой границей устройства. После завершения заполнения будет обновлен индекс ресурсов файловой системы. И уже тогда все узлы в кластере смогут утилизировать новое пространство.

    ***Команду gfs2_grow*** необходимо выполнять в смонтированной файловой системе, но при этом ее нужно запустить только на одном узле в кластере. Все остальные узлы начнут использовать новое пространство автоматически.

    Подробнее: https://access.redhat.com/documentation/ru-ru/red_hat_enterprise_linux/5/html/global_file_system_2/s1-manage-growfs
    </details>


29. Можем ли мы уменьшить размер файловой системы?
    <details>
      <summary> Ответ: </summary>

    Если ***ext 3/4*** можно увеличивать либо уменьшать, то у ***xfs*** уменьшить размер файловой системы нельзя, можно только увеличить.

    Подробнее: https://forum.sys-adm.in/t/lvm/3146
    </details>


30. Что такое chroot и для чего он нужен?
    <details>
      <summary> Ответ: </summary>

    ***chroot*** — операция изменения корневого каталога в Unix-подобных операционных системах. Программа, запущенная с изменённым корневым каталогом, будет иметь доступ только к файлам, содержащимся в данном каталоге.

    ***Разделение привилегий*** — chroot может использоваться как упреждающий способ защиты от бреши в безопасности, предотвращая возможного атакующего от нанесения любых повреждений или зондирования системы с помощью скомпрометированной программы. Например, сетевой файловый сервер может делать chroot в тот каталог, из которого он раздаёт файлы, сразу после соединения с клиентом. Подобный подход используется MTA Postfix, который разделяет свою работу на конвейер меньших, индивидуально заточённых в chroot программ.

    ***Изготовление honeypot-ов*** — chroot-каталог может быть наполнен таким образом, чтобы симулировать реальную систему с запущенными сетевыми сервисами. Механизм chroot в результате может предотвратить обнаружение атакующими системы с целью компрометации от того, что это является искусственным окружением, или от взлома реальной системы.

    Подробнее: https://ru.wikipedia.org/wiki/Chroot
    </details>


31. У нас есть Linux box с 2 Гб оперативной памяти и Java-приложение, которое пытается выделить 4 Гб во время запуска. Удастся ли это?
    <details>
      <summary> Ответ: </summary>
    
    хз

    Подробнее:
    </details>


32. Есть приложение, которое читает файл, который пользователь пытается удалить. Что случится? Можно ли удалить этот файл? Можно ли восстановить этот файл?
    <details>
      <summary> Ответ: </summary>

    хз

    Подробнее:
    </details>


33. Какие механизмы создания процессов в Linux вы знаете?
    <details>
      <summary> Ответ: </summary>

    Для создания процессов используются два системных вызова: ***fork()*** и ***exec***. ***fork()*** создает новое адресное пространство, которое полностью идентично адресному пространству основного процесса. После выполнения этого системного вызова мы получаем два абсолютно одинаковых процесса - основной и порожденный.

    Подробнее: http://www.opennet.ru/docs/RUS/lnx_process/process2.html
    </details>


34. Сравните systemd и init system.
    <details>
      <summary> Ответ: </summary>

    Подробнее: https://www.opennet.ru/opennews/art.shtml?num=30412 (вся инфа)
    </details>


35. У вас есть папка с большим количеством файлов, и вы хотите удалить все файлы с именами, начинающимися на A (прописная буква). Но команда rm –f A* выдает Argument list too long. Как удалить эти файлы?
    <details>
      <summary> Ответ: </summary>

    ***Дело в том***, что использование маски в командах типа ***rm/cp/find*** линукс переводит в удобный для себя формат, делая из понятной человеку команде:

    > $ rm /tmp/logs/*.log

    ***список файлов под этой маской***:

    > $ rm /tmp/logs/1.log /tmp/logs/2.log /tmp/logs/3.log ...

    Проблемы начинаются, когда аргументов у команды rm становится больше допустимого лимита. Проверить этот лимит можно с помощью команды getconf:

    > $ getconf ARG_MAX
    >
    > 262144

    И что все-таки делать?

    ***Использовать цикл For***

    Во-первых, ***циклы нересурсоемкие*** и ***не имеют лимитов на количество аргументов***. Во-вторых, ***в цикл просто завернуть дополнительную логику***, если потребуется делать что-то сложнее, чем удаление файлов.

    Например, вот так можно удалить все файлы одной командой:

    > $ for f in /tmp/logs/*.log; do rm "$f"; done

    Подробнее: https://highload.today/kak-udalit-million-faylov/
    </details>


36. Вы начинаете удалять файлы первым методом из предыдущего вопроса, но каждый rm запрашивает подтверждение. Это очень долго. Как можно ускорить эту операцию?
    <details>
      <summary> Ответ: </summary>

    Подробнее: http://rus-linux.net/MyLDP/consol/8_Examples_Linux_rm_Command_for_Beginners.html (зацепка на ответ)
    </details>
