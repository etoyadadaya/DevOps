## Development:

1. Git. Как решить merge conflict? Что такое rebase, cherry-pick?
    <details>
      <summary> Ответ: </summary>

   ***git cherry-pick***:
   Команда git cherry-pick берёт изменения, вносимые одним коммитом, и пытается повторно применить их в виде нового коммита в текущей ветке. Эта возможность полезна в ситуации, когда нужно забрать парочку коммитов из другой ветки, а не сливать ветку целиком со всеми внесенными в нее изменениями.

   ***git rebase***:
   git rebase - это «автоматизированный» cherry-pick. Он выполняет ту же работу, но для цепочки коммитов, тем самым как бы перенося ветку на новое место.

   ***Git merge conflicts***: https://www.atlassian.com/ru/git/tutorials/using-branches/merge-conflicts

   Подробнее: https://git-scm.com/book/ru/v2/Приложение-C%3A-Команды-Git-Внесение-исправлений
   
   </details>


2. В чем разница между git merge и git rebase?
    <details>
      <summary> Ответ: </summary>

    Согласно официальному руководству Git rebase “повторно применяет коммиты поверх другой базовой ветки”, тогда как merge “объединяет две или более историй разработки”. Иначе говоря, основное отличие между ними в том, что слияние сохраняет историю в первозданном виде, а перебазирование ее перезаписывает.

    </details>


3. Какие UI использовали?
    <details>
      <summary> Ответ: </summary>

   ***1: Визуальный***

   ***2: Текстовый (в частности, интерфейс командной строки)***

   ***3: Графический***:
    > Оконный

    > WIMP

    > Web-ориентированный

    > Индуктивный

    > Масштабируемый

   ***4: Тактильный***

   ***5: Жестовый***

   ***6: Голосовой***

   ***7: Материальный (осязательный)***

   Подробнее: https://ru.wikipedia.org/wiki/Интерфейс_пользователя
    </details>


4. Какая разница между GitLab/GitHub/Bitbucket?
    <details>
      <summary> Ответ: </summary>
   Подробное объяснение: https://stackshare.io/stackups/bitbucket-vs-github-vs-gitlab
    </details>


5. Какая разница между Git pull/Git fetch?
    <details>
      <summary> Ответ: </summary>

   ***При использовании pull***, git пытается сделать всё за вас. Он сливает любые внесённые коммиты в ветку, в которой вы сейчас работаете. Команда pull автоматически сливает коммиты, не давая вам сначала просмотреть их. Если вы не пристально следите за ветками, выполнение этой команды может привести к частым конфликтам.

   ***При использовании fetch***, git собирает все коммиты из целевой ветки, которых нет в текущей ветке, и сохраняет их в локальном репозитории. Однако он не сливает их в текущую ветку. Это особенно полезно, если вам нужно постоянно обновлять свой репозиторий, но вы работаете над функциональностью, неправильная реализация которой может негативно сказаться на проекте в целом. Чтобы слить коммиты в основную ветвь, нужно использовать merge.

   ***Грубо говоря, по дефолту git pull — это шоткод для последовательности двух команд: git fetch (получение изменений с сервера) и git merge (сливание в локальную копию)***.

   Подробнее: https://tproger.ru/explain/git-pull-and-git-fetch-whats-the-difference/
    </details>


6. Что такое Git-Flow?
    <details>
      <summary> Ответ: </summary>

   ***Git-flow*** — альтернативная модель ветвления Git, в которой используются функциональные ветки и несколько основных веток.

   В Git-flow используется больше веток, каждая из которых существует дольше, а коммиты обычно крупнее. В соответствии с этой моделью разработчики создают функциональную ветку и откладывают ее слияние с главной магистральной веткой до завершения работы над функцией. Такие долгосрочные функциональные ветки требуют тесного взаимодействия разработчиков при слиянии и создают повышенный риск отклонения от магистральной ветки. В них также могут присутствовать конфликтующие обновления.

   Подробнее: https://www.atlassian.com/ru/git/tutorials/comparing-workflows/gitflow-workflow
    </details>


7. Версионирование. Какая разница между SemVer и CalVer?
    <details>
      <summary> Ответ: </summary>

   ***Версионирование*** может относиться к:

   ***Нумерация версий программного обеспечения***, процесс присвоения уникальных имен версий или номеров уникальным состояниям компьютерного программного обеспечения.

   ***Система управления версиями***, управление изменениями в документах, компьютерных программах, крупных веб-сайтах и в других коллекциях информации.

   ***Файловая система с версионированием***, что позволяет файлу на компьютере существовать в нескольких версиях одновременно.

   Семантическое Версионирование против Календарного Версионирование:
   https://semver.org/lang/ru/ vs https://calver.org
    </details>


8. Тестирование. Какие существуют виды? Как писать тесты, TDD?
    <details>
      <summary> Ответ: </summary>

    ***Разработка через тестирование (англ. test-driven development, TDD)*** — техника разработки программного обеспечения, которая основывается на повторении очень коротких циклов разработки: сначала пишется тест, покрывающий желаемое изменение, затем пишется код, который позволит пройти тест, и под конец проводится рефакторинг нового кода к соответствующим стандартам.

   ***Модульные тесты***:

   Модульные тесты работают на очень низком уровне, близко к исходному коду приложения. Они заключаются в тестировании отдельных методов и функций классов, компонентов или модулей, используемых в ПО. Модульные тесты, как правило, не требуют больших расходов на автоматизацию и могут выполняться сервером непрерывной интеграции очень быстро.

   ***Интеграционное тестирование***:

   В ходе интеграционного тестирования проверяется, хорошо ли работают вместе различные модули и сервисы, используемые приложением. Например, можно протестировать взаимодействие с базой данных или убедиться, что микросервисы работают вместе так, как задумано. Этот вид тестирования является более затратным, поскольку для проведения тестов требуется запуск различных компонентов приложения.

   ***Функциональные тесты***:

   В функциональных тестах основное внимание уделяется бизнес-требованиям к приложению. Они проверяют только результат некоторого действия и не проверяют промежуточные состояния системы при выполнении этого действия.

   Иногда возникает путаница между понятиями интеграционных и функциональных тестов, так как и те и другие требуют взаимодействия нескольких компонентов друг с другом. Разница в том, что интеграционный тест нужен просто чтобы убедиться, что вы можете отправлять запросы к базе данных, тогда как функциональный тест будет ожидать получения из базы данных определенного значения в соответствии с требованиями продукта.

   ***Сквозные тесты***:

   Сквозное тестирование копирует поведение пользователя при работе с ПО в контексте всего приложения. Оно обеспечивает контроль того, что различные схемы действий пользователя работают должным образом. Сценарии могут быть как очень простыми (загрузка веб-страницы или вход в систему), так и гораздо более сложными (проверка почтовых уведомлений, онлайн-платежей и т. д.).

   Сквозные тесты очень полезны, но их выполнение обходится довольно дорого, к тому же, когда они автоматизированы, такие тесты тяжело обслуживать. Рекомендуется иметь в наличии несколько основных сквозных тестов и активнее полагаться на более низкие уровни тестирования (модульные и интеграционные тесты), чтобы получать возможность быстро выявлять критические изменения.

   ***Приемочное тестирование***:

   Приемочные тесты — это формальные тесты, которые проверяют, отвечает ли система требованиям бизнеса. При этом во время тестирования должно быть запущено само приложение, и основное внимание уделяется воспроизведению поведения пользователей. В ходе этого тестирования возможен даже замер производительности системы, и в случае несоответствия установленным требованиям внесенные изменения могут быть отклонены.

   ***Тестирование производительности***:

   В тестах производительности оценивается работа системы при определенной рабочей нагрузке. С помощью таких тестов можно оценить надежность, скорость, масштабируемость и отзывчивость приложения. Например, это может быть наблюдение за временем отклика при выполнении большого количества запросов или определение поведения системы при работе со значительными объемами данных. Этот вид тестирования позволяет определить, соответствует ли приложение требованиям к производительности, найти узкие места, оценить стабильность при пиковом трафике и многое другое.

   ***Smoke-тестирование***:

   Smoke-тесты — это базовые тесты, которые проверяют основные функциональные возможности приложения. Они должны выполняться быстро, поскольку цель таких тестов — убедиться, что основные возможности системы работают как запланировано.

   Smoke-тесты полезно запускать сразу после создания новой сборки (для определения, можно ли запускать более ресурсоемкие тесты) или сразу после развертывания (чтобы убедиться, что приложение работает правильно в новой, только что развернутой среде).

   Подробнее: https://www.atlassian.com/ru/continuous-delivery/software-testing/types-of-software-testing
    </details>


9. В чем разница между компилируемыми и интерпретационными языками программирования?
    <details>
      <summary> Ответ: </summary>

    ***Простой интерпретатор*** анализирует и тут же выполняет (собственно интерпретация) программу покомандно или построчно по мере поступления её исходного кода на вход интерпретатора. Достоинством такого подхода является мгновенная реакция. Недостаток — такой интерпретатор обнаруживает ошибки в тексте программы только при попытке выполнения команды или строки с ошибкой.

    В отличие от компилируемых языков, интерпретируемым для исполнения программы не нужен машинный код; вместо этого программу построчно исполнят интерпретаторы.

    </details>
