## CI/CD:

1. Что такое Continuous Integration и Continuous Deployment? В чем разница между Continuous Deployment и Continuous Delivery?
    <details>
      <summary> Ответ: </summary>

   ***Непрерывная интеграция*** (CI), ***непрерывная доставка*** (CD) и ***непрерывное развёртывание*** (CD) — devops-подход к разработке и апгрейду программного обеспечения, подразумевающий непрерывное, конвейерное тестирование, сборку, доставку и развёртывание обновлений. Возможно как отдельное применение компонентов этого подхода (CI или CI + CD), так и их последовательное использование в рамках единого процесса (CI + CD + CD).

   ***Непрерывная интеграция*** (CI):
   ***Непрерывная интеграция*** (CI) — первичный, базовый процесс обновления ПО, в рамках которого все изменения на уровне кода вносятся в единый центральный репозиторий. Такое внесение принято называть слиянием. После каждого слияния (которое проходит по несколько раз в день) в изменяемой системе происходит автоматическая сборка (часто приложение упаковывается в Docker) и тестирование (проверка конкретных модулей кода, UI, производительности, надёжности API). Таким образом разработчики страхуются от слишком поздних обнаружений проблем в обновлениях.

   ***Непрерывная доставка*** (CD):
   ***Непрерывная доставка*** (CD) — CI + CD. Следующий после CI уровень. Теперь новая версия не только создаётся и тестируется при каждом изменении кода, регистрируемом в репозитории, но и может быть оперативно запущена по одному нажатию кнопки развёртывания. Однако запуск развёртывания всё ещё происходит вручную — ту самую кнопку всё же надо кому-то нажать. Этот метод позволяет выпускать изменения небольшими партиями, которые легко изменить или устранить в случае необходимости.

   ***Непрерывное развёртывание*** (CD):
   ***Непрерывное развёртывание*** (CD) — CI +CD + CD. После автоматизации релиза остаётся один ручной этап: одобрение и запуск развёртывания в продакшен (злосчастная кнопка). Практика непрерывного развёртывания упраздняет и это, не требуя непосредственного утверждения со стороны разработчика. Все изменения развёртываются автоматически.

   Как правило, под CI/CD подразумеваются только непрерывная интеграция и доставка.

   ***В чем разница между Continuous Deployment и Continuous Delivery***?

   В случае Continuous Deployment каждый следующий шаг, будет выполнен автоматически если предыдущий был успешный, включая деплой на Production.

   Если же у вас Continuous Delivery, то шаги будут выполняться автоматически только в безопасной среде, а перед деплоем на Production пайплайн остановится и будет ждать ручного подтверждения.

   </details>
   

2. Опишите основные этапы CI/CD.
    <details>
      <summary> Ответ: </summary>

   1: ***Написание кода***. Разработчики пишут код своего модуля и проводят тестирование в ручном режиме. После этого результат работы соединяется в главной ветке с текущей версией проекта. После того, как в главной ветке публикуются все коды модулей, начинается второй этап.
   
   2: ***Сборка***. Выбранная система контроля версий инициирует автоматическую сборку и последующее тестирование проекта. Триггеры для активации сборки могут быть настроены самостоятельно. Для автоматизации сборки применяется Jenkins или другой инструмент.

   3: ***Ручное тестирование***. После проверки CI-системой работоспособности тестовой версии код передается для ручного исследования.
   
   4: ***Релиз***. После ручного тестирования в сборку вносятся исправления. Следом проходит релиз версии кода для клиентов.
   
   5: ***Развертывание***. На этом этапе текущая (рабочая) версия кода размещается на production-серверах разработчика. Клиент может взаимодействовать с программой и изучать ее функции.
   
   6: ***Поддержка и мониторинг***. Продукт начинает использоваться конечными пользователями. При этом разработчики продолжают его поддерживать и проводят анализ пользовательского опыта.
   
   7: ***Планирование***. Исходя из пользовательского опыта разрабатывается новый функционал и готовится план доработок. После этого разработчик начинает написание кода — и цикл замыкается.

   Подробнее: https://sbercloud.ru/ru/warp/cicd-about
    </details>


3. Опишите пример процесса CI (и/или CD), который начинается с момента, когда разработчик запушил изменения/PR в Git?
    <details>
      <summary> Ответ: </summary>
      Пока хз
    </details>


4. Расскажите о разновидностях тестов, которые мы можем использовать в CI пайплайне.
    <details>
      <summary> Ответ: </summary>

   ***Юнит-тесты***.

   ***Сервисные тесты***.

   ***Тесты пользовательского интерфейса***.   

   Подробнее: https://habr.com/ru/post/358950/
    </details>


5. Какие инструменты CI вы использовали? Есть ли опыт работы с Jenkinsfile?
    <details>
      <summary> Ответ: </summary>

    ***Bitbucket Pipelines, Jenkins, GitLab***

    Подробнее: https://www.atlassian.com/ru/continuous-delivery/continuous-integration/tools
    </details>


6. Какие виды тестов вы знаете и зачем они нужны?
    <details>
      <summary> Ответ: </summary>

   ***Модульные тесты***:

   Модульные тесты работают на очень низком уровне, близко к исходному коду приложения. Они заключаются в тестировании отдельных методов и функций классов, компонентов или модулей, используемых в ПО. Модульные тесты, как правило, не требуют больших расходов на автоматизацию и могут выполняться сервером непрерывной интеграции очень быстро.

   ***Интеграционное тестирование***:

   В ходе интеграционного тестирования проверяется, хорошо ли работают вместе различные модули и сервисы, используемые приложением. Например, можно протестировать взаимодействие с базой данных или убедиться, что микросервисы работают вместе так, как задумано. Этот вид тестирования является более затратным, поскольку для проведения тестов требуется запуск различных компонентов приложения.

   ***Функциональные тесты***:

   В функциональных тестах основное внимание уделяется бизнес-требованиям к приложению. Они проверяют только результат некоторого действия и не проверяют промежуточные состояния системы при выполнении этого действия.

   Иногда возникает путаница между понятиями интеграционных и функциональных тестов, так как и те и другие требуют взаимодействия нескольких компонентов друг с другом. Разница в том, что интеграционный тест нужен просто чтобы убедиться, что вы можете отправлять запросы к базе данных, тогда как функциональный тест будет ожидать получения из базы данных определенного значения в соответствии с требованиями продукта.

   ***Сквозные тесты***:

   Сквозное тестирование копирует поведение пользователя при работе с ПО в контексте всего приложения. Оно обеспечивает контроль того, что различные схемы действий пользователя работают должным образом. Сценарии могут быть как очень простыми (загрузка веб-страницы или вход в систему), так и гораздо более сложными (проверка почтовых уведомлений, онлайн-платежей и т. д.).

   Сквозные тесты очень полезны, но их выполнение обходится довольно дорого, к тому же, когда они автоматизированы, такие тесты тяжело обслуживать. Рекомендуется иметь в наличии несколько основных сквозных тестов и активнее полагаться на более низкие уровни тестирования (модульные и интеграционные тесты), чтобы получать возможность быстро выявлять критические изменения.

   ***Приемочное тестирование***:

   Приемочные тесты — это формальные тесты, которые проверяют, отвечает ли система требованиям бизнеса. При этом во время тестирования должно быть запущено само приложение, и основное внимание уделяется воспроизведению поведения пользователей. В ходе этого тестирования возможен даже замер производительности системы, и в случае несоответствия установленным требованиям внесенные изменения могут быть отклонены.

   ***Тестирование производительности***:

   В тестах производительности оценивается работа системы при определенной рабочей нагрузке. С помощью таких тестов можно оценить надежность, скорость, масштабируемость и отзывчивость приложения. Например, это может быть наблюдение за временем отклика при выполнении большого количества запросов или определение поведения системы при работе со значительными объемами данных. Этот вид тестирования позволяет определить, соответствует ли приложение требованиям к производительности, найти узкие места, оценить стабильность при пиковом трафике и многое другое.

   ***Smoke-тестирование***:

   Smoke-тесты — это базовые тесты, которые проверяют основные функциональные возможности приложения. Они должны выполняться быстро, поскольку цель таких тестов — убедиться, что основные возможности системы работают как запланировано.

   Smoke-тесты полезно запускать сразу после создания новой сборки (для определения, можно ли запускать более ресурсоемкие тесты) или сразу после развертывания (чтобы убедиться, что приложение работает правильно в новой, только что развернутой среде).

   Подробнее: https://www.atlassian.com/ru/continuous-delivery/software-testing/types-of-software-testing
    </details>
